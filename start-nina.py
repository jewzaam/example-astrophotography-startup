# Generated By: Cursor (Claude Sonnet 4.5)
"""
Start programs in sequence if a specified program is not already running.
Checks if a configured program is running; if it is, skips starting all programs.
"""

import argparse
import json
import logging
import os
import shutil
import subprocess
import sys
import threading
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s: %(message)s'
)
logger = logging.getLogger(__name__)


def is_program_running(process_name: str) -> bool:
    """Check if a program is already running by searching for the process_name in process list."""
    try:
        result = subprocess.run(
            ["tasklist"],
            capture_output=True,
            text=True,
            check=False,
        )
        return process_name.lower() in result.stdout.lower()
    except Exception as e:
        logger.error(f"Error checking if program is running: {e}")
        return False


def stream_output(pipe, output_channel, program_name: str):
    """Stream output from a pipe to the specified output channel."""
    try:
        for line in iter(pipe.readline, ''):
            if line:
                print(line.rstrip(), file=output_channel, flush=True)
    except Exception as e:
        logger.error(f"Error streaming output for {program_name}: {e}")
    finally:
        if pipe:
            pipe.close()


def start_program(program_path: str, args: list, program_name: str = None, foreground: bool = True) -> bool:
    """Start a program with command line arguments and stream its output.
    
    Args:
        program_path: Path to the executable
        args: Command line arguments
        program_name: Display name for the program
        foreground: If True, wait for program to complete. If False, start and continue immediately.
    """
    # First, try to resolve as a file path
    program_path_obj = Path(program_path)
    if program_path_obj.is_absolute():
        resolved_path = program_path_obj
    else:
        # Try to resolve relative path
        resolved_path = program_path_obj.resolve()
    
    # If not found as a file, try to find in PATH
    if not resolved_path.exists():
        which_path = shutil.which(program_path)
        if which_path:
            resolved_path = Path(which_path)
        else:
            logger.error(f"Program executable not found: {program_path}")
            return False
    
    if not resolved_path.exists():
        logger.error(f"Program executable not found at: {resolved_path}")
        return False

    try:
        cmd = [str(resolved_path)] + args
        logger.info(f"Starting: {' '.join(cmd)}")
        
        process = subprocess.Popen(
            cmd,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )
        
        # Start threads to stream stdout and stderr
        # For background programs, use daemon threads so they don't block exit
        stdout_thread = threading.Thread(
            target=stream_output,
            args=(process.stdout, sys.stdout, program_name or Path(program_path).name),
            daemon=not foreground
        )
        stderr_thread = threading.Thread(
            target=stream_output,
            args=(process.stderr, sys.stderr, program_name or Path(program_path).name),
            daemon=not foreground
        )
        
        stdout_thread.start()
        stderr_thread.start()
        
        if foreground:
            # Wait for process to complete and threads to finish reading output
            return_code = process.wait()
            stdout_thread.join()
            stderr_thread.join()
            
            if return_code != 0:
                logger.warning(f"Program exited with return code {return_code}")
        else:
            logger.info(f"Started background program (not waiting for completion)")
        
        return True
    except Exception as e:
        logger.error(f"Error starting program: {e}")
        return False


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Start programs in sequence if a specified program is not already running'
    )
    parser.add_argument(
        '--config',
        required=True,
        help='Path to JSON configuration file'
    )
    
    args = parser.parse_args()
    
    # Load configuration
    if not os.path.exists(args.config):
        logger.error(f"Config file not found: {args.config}")
        return 1
    
    try:
        with open(args.config, 'r') as f:
            config = json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in config file: {e}")
        return 1
    except Exception as e:
        logger.error(f"Error reading config file: {e}")
        return 1
    
    # Validate required configuration
    if 'programs' not in config:
        logger.error("Missing required configuration key: 'programs'")
        return 1
    
    programs = config['programs']
    if not isinstance(programs, list):
        logger.error("'programs' must be an array")
        return 1
    
    if len(programs) == 0:
        logger.error("'programs' array must contain at least one program")
        return 1
    
    # Validate each program structure
    for i, program in enumerate(programs):
        if not isinstance(program, dict) or 'path' not in program:
            logger.error(f"Program at index {i} must be a dictionary with 'path' key")
            return 1
    
    # Get the process name to check (required at root level)
    skip_if_running = config.get('skip_if_running')
    if not skip_if_running:
        logger.error("Missing required configuration key: 'skip_if_running'")
        return 1
    
    if not isinstance(skip_if_running, str):
        logger.error("'skip_if_running' must be a string")
        return 1
    
    # Check if the specified process is already running
    if is_program_running(skip_if_running):
        logger.info(f"Process '{skip_if_running}' is already running, skipping startup")
        return 0
    
    # Start all programs in order
    for i, program in enumerate(programs):
        program_path = program['path']
        program_args = program.get('args', [])
        program_foreground = program.get('foreground', True)  # Default to foreground for backward compatibility
        program_name = Path(program_path).name
        mode_str = "foreground" if program_foreground else "background"
        logger.info(f"Starting program {i+1}/{len(programs)} ({mode_str}): {program_name}")
        if not start_program(program_path, program_args, program_name, program_foreground):
            logger.error(f"Failed to start program {i+1}")
            return 1
    
    logger.info(f"All {len(programs)} program(s) started successfully")
    return 0


if __name__ == '__main__':
    sys.exit(main())

