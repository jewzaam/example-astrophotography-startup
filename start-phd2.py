# Generated By: Cursor (Claude Sonnet 4.5)
"""Start PHD2 and connect devices if not already running/connected."""

import argparse
import subprocess
import sys
import threading
import time
from pathlib import Path

try:
    from phd2client.guider import Guider, GuiderError
except ImportError:
    print("Error: phd2client library not found. Install with: pip install phd2client")
    sys.exit(1)


def is_phd2_running(phd2_path: str) -> bool:
    """Check if PHD2 is already running based on the executable path."""
    try:
        # Extract executable name from path
        exe_name = Path(phd2_path).name
        result = subprocess.run(
            ["tasklist", "/FI", f"IMAGENAME eq {exe_name}"],
            capture_output=True,
            text=True,
            check=False,
        )
        return exe_name in result.stdout
    except Exception as e:
        print(f"Error checking if PHD2 is running: {e}")
        return False


def start_phd2(phd2_path: str) -> bool:
    """Start PHD2."""
    if not Path(phd2_path).exists():
        print(f"Error: PHD2 executable not found at: {phd2_path}")
        return False

    try:
        print(f"Starting PHD2 from: {phd2_path}")
        subprocess.Popen([phd2_path], shell=True)
        return True
    except Exception as e:
        print(f"Error starting PHD2: {e}")
        return False


def wait_for_phd2_server(host: str = "localhost", port: int = 4400, timeout: int = 30) -> bool:
    """Wait for PHD2 server to be ready to accept connections."""
    import socket

    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((host, port))
            sock.close()
            if result == 0:
                print("PHD2 server is ready")
                return True
        except Exception:
            pass
        time.sleep(1)
    print(f"Timeout waiting for PHD2 server on {host}:{port}")
    return False


def connect_equipment(guider: Guider, profile_name: str) -> bool:
    """Connect equipment using the specified profile with a 30 second timeout."""
    connection_timeout = 30  # Hard-coded timeout in seconds
    
    result_container = {'success': False, 'exception': None, 'completed': False}
    
    def _connect():
        """Internal function to perform the connection."""
        try:
            guider.ConnectEquipment(profile_name)
            # Give it a moment to connect
            time.sleep(2)
            result_container['success'] = True
        except GuiderError as e:
            error_msg = str(e).lower()
            # If equipment is already connected, that's fine
            if "already connected" in error_msg or "connected" in error_msg:
                result_container['success'] = True
            else:
                result_container['exception'] = e
        except Exception as e:
            result_container['exception'] = e
        finally:
            result_container['completed'] = True
    
    print(f"Connecting equipment using profile: {profile_name} (timeout: {connection_timeout}s)")
    
    # Start connection in a daemon thread (can be orphaned if it hangs)
    connection_thread = threading.Thread(target=_connect, daemon=True)
    connection_thread.start()
    connection_thread.join(timeout=connection_timeout)
    
    # Check if connection completed
    if not result_container['completed']:
        print(f"Warning: Equipment connection timed out after {connection_timeout} seconds (popup may be blocking)")
        print("Continuing anyway - connection thread will be orphaned")
        # Thread is daemon, so it won't block script exit even if still running
        return True  # Return True to allow script to continue
    
    # Connection completed, check result
    if result_container['success']:
        print("Equipment connection command sent successfully")
        return True
    
    # Connection failed
    if result_container['exception']:
        exception = result_container['exception']
        if isinstance(exception, GuiderError):
            print(f"Guider error connecting equipment: {exception}")
        else:
            print(f"Error connecting equipment: {exception}")
    
    return False


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Start PHD2 and connect devices if not already running/connected"
    )
    parser.add_argument(
        "--phd2-path",
        type=str,
        default="C:\\Program Files (x86)\\PHDGuiding2\\PHD2.exe",
        help="Path to PHD2 executable (default: C:\\Program Files (x86)\\PHDGuiding2\\PHD2.exe)",
    )
    parser.add_argument(
        "--profile",
        type=str,
        required=True,
        help="Equipment profile name to connect (e.g., 'Simulator')",
    )
    parser.add_argument(
        "--host",
        type=str,
        default="localhost",
        help="PHD2 server host (default: localhost)",
    )
    parser.add_argument(
        "--port",
        type=int,
        default=4400,
        help="PHD2 server port (default: 4400)",
    )
    parser.add_argument(
        "--startup-timeout",
        type=int,
        default=30,
        help="Timeout in seconds to wait for PHD2 to start (default: 30)",
    )

    args = parser.parse_args()

    # Step 1: Start PHD2 if not running
    phd2_was_running = is_phd2_running(args.phd2_path)
    if not phd2_was_running:
        if not start_phd2(args.phd2_path):
            print("Failed to start PHD2")
            return 1
        # Wait for PHD2 server to be ready
        if not wait_for_phd2_server(args.host, args.port, args.startup_timeout):
            print("PHD2 started but server not ready")
            return 1
    else:
        print("PHD2 is already running")
        # Verify server is accessible (quick check with short timeout)
        if not wait_for_phd2_server(args.host, args.port, timeout=5):
            print("Warning: PHD2 is running but server may not be ready")
            # Continue anyway - connection attempt will fail if server is down

    # Step 2: Connect to PHD2 and connect equipment
    try:
        print(f"Connecting to PHD2 at {args.host}")
        # Try with connect=True first (newer API), fall back to explicit Connect()
        try:
            guider = Guider(args.host, connect=True)
        except TypeError:
            # Older API - connect explicitly
            guider = Guider(args.host)
            guider.Connect()
    except GuiderError as e:
        print(f"Failed to connect to PHD2: {e}")
        return 1
    except Exception as e:
        print(f"Error connecting to PHD2: {e}")
        return 1

    # Step 3: Connect equipment (will handle already-connected case)
    try:
        if not connect_equipment(guider, args.profile):
            print("Failed to connect equipment")
            return 1
    finally:
        # Clean up connection if needed
        try:
            if hasattr(guider, 'Disconnect'):
                guider.Disconnect()
        except Exception:
            pass

    print("PHD2 is ready with equipment connected")
    return 0


if __name__ == "__main__":
    sys.exit(main())

